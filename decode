#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include <locale.h>

struct letter{
	char value;
	char code[9999];
	int digit;
	int fre;
	int sayac;
	struct letter *right;
    struct letter *left;	
};
struct tree {
    struct letter *arr;
};

struct letter* input(int *base_size){
	struct letter *base=(struct letter*)malloc(999999*sizeof(struct letter));
	
	if (!base) {
        perror("Memory allocation failed");
        exit(EXIT_FAILURE);
    }
    

	FILE *in;
	in=fopen("output.txt","r");
	*base_size=0;
	while(fscanf(in,"%c %d ",&base[*base_size].value,&base[*base_size].fre)==2){
		(*base_size)++;
	
	}
	base=(struct letter*)realloc(base,(*base_size)*sizeof(struct letter));

	fclose(in);
	
	struct tree *build = (struct tree*) malloc(sizeof(struct tree));    
    build->arr = (struct letter*) malloc( (*base_size) * 2 * sizeof(struct letter));
    struct letter *nodes=(struct letter*) malloc( *base_size * 2 * sizeof(struct letter));
    if (!build->arr || !build || !nodes) {
        perror("Memory allocation failed");
        exit(EXIT_FAILURE);
    }
	for (int i = 0; i < 2 * (*base_size); i++) {
        build->arr[i].value ='\0';
		build->arr[i].code[0] ='\0';
		build->arr[i].digit=0;
        build->arr[i].fre = 0;
        build->arr[i].sayac=0;
        build->arr[i].right = NULL;
        build->arr[i].left = NULL;
    }
    	 
    for (int i = 0; i < *base_size; i++) {
    	nodes[i].value = '\0';
        nodes[i].code[0] ='\0';
        nodes[i].digit=0;
        nodes[i].fre = 0;
        nodes[i].left = NULL;
        nodes[i].right = NULL;
    }
   
   
	nodes[0].left = &base[0];
	if(base[1].fre!=0){
		nodes[0].right = &base[1];
	}
	
    if(base[1].fre!=0){
    	nodes[0].fre = base[1].fre + base[0].fre;
	}
	else{
		nodes[0].fre = base[0].fre;
	}
	int k=0;
	int n_size=0;
	
	if(base[1].fre!=0){
		build->arr[1] = base[1];
		build->arr[2] = nodes[0];
		build->arr[0] = base[0];
		k=3;
		n_size=1;
		for (int i = 2; i < *base_size; i++) {
	        nodes[n_size].right = &nodes[n_size - 1];
	        nodes[n_size].left = &base[i];
	        nodes[n_size].fre = nodes[n_size - 1].fre + base[i].fre;
	
	        build->arr[k++] = base[i];
	        build->arr[k++] = nodes[n_size];
	
	        n_size++;
	    }
	}else{
		build->arr[0] = base[0];
    	build->arr[1] = nodes[0];
    	n_size=1;
    	k=2;
	}if(base[1].fre!=0){
		build->arr[1] = base[1];
		build->arr[2] = nodes[0];
		build->arr[0] = base[0];
		k=3;
		n_size=1;
		for (int i = 2; i < *base_size; i++) {
	        nodes[n_size].right = &nodes[n_size - 1];
	        nodes[n_size].left = &base[i];
	        nodes[n_size].fre = nodes[n_size - 1].fre + base[i].fre;
	
	        build->arr[k++] = base[i];
	        build->arr[k++] = nodes[n_size];
	
	        n_size++;
	    }
	}else{
		build->arr[0] = base[0];
    	build->arr[1] = nodes[0];
    	n_size=1;
    	k=2;
	}
    
    
	int a_size = n_size + *base_size;
	
	build->arr = (struct letter*) realloc(build->arr, (a_size) * sizeof(struct letter));
	if (!build->arr) {
        perror("Memory allocation failed");
        exit(EXIT_FAILURE);
    }
	
	
	//code assigment
    int syc=1;
    
    if(base[1].fre!=0){
    	build->arr[(a_size)-1].code[0]='\0';
    	
	    build->arr[(a_size)-2].code[0]='0';
	    build->arr[(a_size)-2].code[1]='\0';
	    build->arr[(a_size)-2].digit=1;
	    
	    build->arr[(a_size)-3].code[0]='1';
	    build->arr[(a_size)-3].code[1]='\0';
	    build->arr[(a_size)-3].digit=1;
	   	
	    for(int i=(a_size)-3;i>2;i-=2){
	    	strcpy(build->arr[i-2].code,build->arr[i].code);
	    	build->arr[i-2].code[syc]='1';
	    	build->arr[i-2].code[syc+1]='\0';
	    	build->arr[i-2].digit=syc+1;
	    	
	    	strcpy(build->arr[i-1].code,build->arr[i].code);
	    	build->arr[i-1].code[syc]='0';
	    	build->arr[i-1].code[syc+1]='\0';
			build->arr[i-1].digit=syc+1;	
			syc++;
		}
		strcpy(build->arr[0].code,build->arr[2].code);
		build->arr[0].code[syc]='1';
		build->arr[0].code[syc+1]='\0';
		build->arr[0].digit=syc+1;
		
		strcpy(build->arr[1].code,build->arr[2].code);
	   	build->arr[1].code[syc]='0';
		build->arr[1].code[syc+1]='\0';
		build->arr[1].digit=syc+1;
	}else{
		build->arr[(a_size)-1].code[0]='\0';
		
	    build->arr[(a_size)-2].code[0]='0';
	    build->arr[(a_size)-2].code[1]='\0';
	    build->arr[(a_size)-2].digit=1;
	}
	
	int m=2;
	base[0]=build->arr[0];
	if(base[1].fre!=0){
		base[1]=build->arr[1];
		for(int i=3;i<a_size;i+=2){
			base[m++]=build->arr[i];
		}
	}
	
	free(build->arr);
	free(nodes);
	free(build);

	return base;
	
}

char* pasword(int *code_size){
	setlocale(LC_ALL, "");
	FILE *pas;
	pas=fopen("output.txt","r");
	char l[30];
	int bin[300],syc=0;
	char *code_arr;
	code_arr=(char*)malloc(9999*sizeof(char));
	
	fgets(l, 3000, pas);
	
	wint_t x;

    while ((x = fgetwc(pas)) != WEOF) {
        if (x != L'\n') {
        	bin[syc]=(int)x;		
        }
      	printf("%lc * %d\n", x, bin[syc]);
      	syc++;
    }
    
    
    int temp;
    for(int i=0;i<syc;i++){
    	temp=bin[i];
    	
    	for(int j=7;j>=0;j--){
    		
    		if(temp!=0){
    			if(temp%2==1){
    				code_arr[j+(8*i)]='1';
				}else if(temp%2==0){
					code_arr[j+(8*i)]='0';
				}
					temp/=2;
			}else{		
	    		
	    		code_arr[j+(8*i)]='0';
			}
		
		}
	}
	*code_size=syc*8;
	code_arr=(char*)realloc(code_arr,(*code_size)*sizeof(char));
	printf("\n");
	for(int i=0;i<*code_size;i++){
		printf("%c",code_arr[i]);
	}
	
	return code_arr;
}

char* decode(char *b_code,int b_size,struct letter *input,int in_size,int *out_size){
	
	char *out=(char*)malloc(b_size*sizeof(char));
 	*out_size=0;
 	int c=1;
	
	for(int k=0;k<b_size&&c;k+=0){
		for(int j=0;j<in_size;j++){
			if(strncmp(&b_code[k],input[j].code,input[j].digit)==0){
				if(input[j].sayac<input[j].fre){
					(input[j].sayac)++;
					out[*out_size]=input[j].value;
					k+=(input[j].digit);
					(*out_size)++;
					break;	
				}
			}
		}
		c=0;
		for(int i=0;i<in_size;i++){
			
			if(input[i].sayac<input[i].fre){
				c=1;
			}
		}
	}
	return out;
}

int main(){
	struct letter *info;
	int letter_size,bin_size;
	info=input(&letter_size);
	
	for(int i=0;i<letter_size;i++){
		printf("%c * %s * %d * %d\n",info[i].value,info[i].code,info[i].fre,info[i].digit);
	}
	char *binary;
	binary=pasword(&bin_size);
	
	int msg_size;
	char *output;
	
	output=decode(binary,bin_size,info,letter_size,&msg_size);
	printf("\n");
	printf("%s",output);

	
	FILE *last;
	last=fopen("last.txt","w");
	fprintf(last,"%s",output);
	
	fclose(last);
	
	
	

}
