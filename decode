#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>

struct letter{
    char value;
    int frequence;
    char code[9];
    struct letter *right;
    struct letter *left;
    int digit;
    int counter;
    int flag;
};
struct letter* open_file(int *first_size);
struct letter* build_tree(struct letter *leafs, int *tree_size);
int find_min(struct letter *a, int a_size, int *first_min, int *second_min);
void create_code(struct letter *node, char cod[]);
char* pasword(int *code_size);
char* decode(char *binary_code,int binary_size,struct letter *input,int in_size,int *out_size);

int main(void){
    int size;
    struct letter *data;
    int data_size;
    data=open_file(&size);
    data_size=size;
    struct letter *coded;
    coded=build_tree(data, &size);
    for(int i=0; i<size; i++){
        if(coded[i].flag==0){
            create_code(&coded[i], "0");
        }
    }
    int binary_text_size;
    char *binary_text=(char*)malloc(99999*sizeof(char));
    binary_text = pasword(&binary_text_size);
    int text_size=0;
    char *text;
    text=decode(binary_text, binary_text_size, data, data_size, &text_size);
    printf("%s",text);
}

struct letter* open_file(int *first_size){
    FILE *input;
    input=fopen("output.txt", "r");
    struct letter *first_take=(struct letter*)malloc(256*sizeof(struct letter));
    if (!first_take) {
        perror("Memory allocation failed");
        return NULL;
    }
    *first_size=0;
    while(fscanf(input, "%c %d", &first_take[*first_size].value, &first_take[*first_size].frequence)==2){
        first_take[*first_size].code[0]='\0';
        first_take[*first_size].left=NULL;
        first_take[*first_size].right=NULL;
        first_take[*first_size].counter=0;
        first_take[(*first_size)++].digit=0;
    }
    fclose(input);
    first_take=(struct letter*)realloc(first_take, (*first_size)*sizeof(struct letter));
    if (!first_take) {
        perror("Memory allocation failed");
        return NULL;
    }
    return first_take;
}

struct letter* build_tree(struct letter *leafs, int *tree_size) {
    struct letter *main_tree = (struct letter *)malloc(*tree_size * 2 * sizeof(struct letter));
    if (!main_tree) {
        perror("Memory allocation failed");
        return NULL;
    }

    for (int i = 0; i < *tree_size * 2; i++) {
        main_tree[i].code[0] = '\0';
        main_tree[i].left = NULL;
        main_tree[i].right = NULL;
        main_tree[i].value = '\0';
        main_tree[i].frequence = 0;
        main_tree[i].digit=0;
        main_tree[i].counter=0;
        main_tree[i].flag=0;
    }
    main_tree = leafs;
    int min1 = 0, min2 = 0;

    while (find_min(main_tree, *tree_size, &min1, &min2)) {
        main_tree[*tree_size].left = &main_tree[min1];
        main_tree[*tree_size].right = &main_tree[min2];
        main_tree[*tree_size].frequence = main_tree[min1].frequence + main_tree[min2].frequence;
        (*tree_size)++;
    }
    main_tree[min1].flag = 0;
    return main_tree;
}

int find_min(struct letter *a, int a_size, int *first_min, int *second_min) {
    int end = 1;
    *first_min = a_size - 1;
    for (int i = 0; i < a_size; i++) {
        if (a[i].flag == 0 && a[i].frequence < a[*first_min].frequence) {
            *first_min = i;
        }
    }
    a[*first_min].flag = 1;
    for (int i = 0; i < a_size; i++) {
        if (a[i].flag == 0) {
            *second_min = i;
            end = 0;
            break;
        }
    }
    if (end) {
        return 0;
    }
    for (int i = 0; i < a_size; i++) {
        if (a[i].flag == 0 && a[i].frequence < a[*second_min].frequence) {
            *second_min = i;
        }
    }
    a[*second_min].flag = 1;
    return 1;
}
void create_code(struct letter *node, char cod[]) {
    strcat(node->code, cod);
    printf("%s/// %d***%c\n", node->code, node->frequence, node->value);
    if (node->left != NULL) {
        strcpy(node->left->code, node->code);
        create_code(node->left, "0");
    }
    if (node->right != NULL) {
        strcpy(node->right->code, node->code);
        create_code(node->right, "1");
    }
}

char* pasword(int *code_size){
    setlocale(LC_ALL, "");
    FILE *pas;
    pas=fopen("output.txt","r");
    char l[9999];
    int bin[99999],syc=0;
    char *code_arr;
    code_arr=(char*)malloc(9999*sizeof(char));
    if (!code_arr) {
        perror("Memory allocation failed");
        return NULL;
    }
    
    fgets(l, 3000, pas);

    wint_t x;

    while ((x = fgetwc(pas)) != WEOF) {
        if (x != L'\n') {
            bin[syc]=(int)x;
        }
          printf("%lc * %d\n", x, bin[syc]);
          syc++;
    }
    
    int temp;
    for(int i=0;i<syc;i++){
        temp=bin[i];

        for(int j=7;j>=0;j--){
            if(temp!=0){
                if(temp%2==1){
                    code_arr[j+(8*i)]='1';
                }else if(temp%2==0){
                    code_arr[j+(8*i)]='0';
                }
                    temp/=2;
            }else{

                code_arr[j+(8*i)]='0';
            }

        }
    }
    *code_size=syc*8;
    code_arr=(char*)realloc(code_arr,(*code_size)*sizeof(char));
    if (!code_arr) {
        perror("Memory allocation failed");
        return NULL;
    }
    printf("\n");
    for(int i=0;i<*code_size;i++){
        printf("%c",code_arr[i]);
    }

    return code_arr;
}
char* decode(char *binary_code,int binary_size,struct letter *input,int in_size,int *out_size){

    char *out=(char*)malloc(binary_size*sizeof(char));
     *out_size=0;
     int control=1;
    for (int i=0; i<in_size; i++) {
        input[i].digit= (int)strlen(input[i].code);
    }
    
    for(int i=0; i<binary_size && control; i+=0){
        for(int j=0; j<in_size; j++){
            if(strncmp(&binary_code[i], input[j].code, input[j].digit)==0){
                if(input[j].counter<input[j].frequence){
                    (input[j].counter)++;
                    out[*out_size]=input[j].value;
                    i+=(input[j].digit);
                    (*out_size)++;
                    break;
                }
            }
        }
        control=0;
        for(int i=0;i<in_size;i++){
            if(input[i].counter<input[i].frequence){
                control=1;
            }
        }
    }
    return out;
}



